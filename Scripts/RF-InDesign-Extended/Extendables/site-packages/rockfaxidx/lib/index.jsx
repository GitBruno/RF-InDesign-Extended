// rfidxvar CustomScriptFolderName = "RF-InDesign-Extended";$.level = 0;/** * @desc A module containing useful rockfax shit. * * You can make anything from within this module available to scripts * by adding it to the ``exports`` variable, e.g. * *    // in this module: *    exports.MyClass = function MyClass () { } * *    // in your scripts: *    var MyClass = require("thismodule").MyClass; * * All modules have access to two global variables, outside of what * ExtendScript offers by itself: ``exports`` and ``module``, which * contains the module id and its path. * * __core__.jsx serves as the main module. You may add other files in this directory. * They will be available as submodules, and can be accessed using e.g. * ``require("thismodule/submod")`` * * Note that modules may require other modules as well as submodules, * so avoid using #include wherever possible. * * If you're unsure as to how to proceed, check Extendables' built-in modules. * Those modules will give you a better feel for how things work. */  exports.ContextMenus = function () {    this.beforeDisplay = function (mnuName) {    var myLayoutContextMenu = app.menus.item(mnuName);    var sel,labelTitles,tempArray;    sel = app.selection;    if (sel.length === 0) {return;}        labelTitles = exports.decideScript(sel);    this.removeOldMenuItems();        if(app.documents.length !== 0) {      if(app.selection.length > 0) {        if (labelTitles == "") {return;}        this.addContextMenuItem(labelTitles, mnuName);      }    }  };    this.removeOldMenuItems = function () {    for (var i = 0; i < Potentials.length; i++) {      try {        myLayoutContextMenu.menuItems.item(Potentials[i]).remove();      } catch (e) {}      try {        app.scriptMenuActions.item(Potentials[i]).remove();      } catch (e) {}    }  };    this.checkForScriptMenuItem = function (mnuTitle) {    var myResult = false;    try{      var myScriptMenuAction = app.scriptMenuActions.item(mnuTitle);      myScriptMenuAction.name;      return myScriptMenuAction;    }    catch(myError){}    return myResult;  };  this.addContextMenuItem = function (titleArray, mnuName) {    var sma;    var matchingScripts;    matchingScripts = this.findScriptPaths(titleArray);    for (var k = 0; k < matchingScripts.length; k++) {      var menuTitle = matchingScripts[k].displayName.replace(/\.\w+$/, "");      if (matchingScripts[k] === undefined) {continue;}      sma = this.checkForScriptMenuItem(menuTitle);      if(sma == false) {        sma = app.scriptMenuActions.add(menuTitle);        sma = this.addEventListener (sma, matchingScripts[k].fsName, menuTitle);      }      app.menus.item(mnuName).menuItems.add(sma);    }  };    this.findScriptPaths = function (names) {    if (names.constructor.name != 'Array') names = [names];    if (names[0] && names[0].match(/\//)) {      var scriptFolder = exports.IDRockfaxFolder().fsName;      for (var i = 0; i < names.length; i++) {        names[i] = scriptFolder + names[i];      }      return names;    }    var regex = new RegExp(names.join("|"));    return exports.filesMatching(regex);  };    this.addEventListener = function (scriptMenuAction, scriptPath, menuTitle) {    var handler = function() {      app.doScript (scriptPath, undefined, undefined, UndoModes.entireScript, menuTitle);    };    scriptMenuAction.eventListeners.everyItem().remove();    scriptMenuAction.addEventListener(      'onInvoke',      handler,      false    );    return scriptMenuAction;  };    return this;};exports.Prefs = function () {  this.prefsPath = exports.filesMatching("rfidx_prefs.json");  this.currentModifiedDate = File(this.prefsPath).modified;  this.str = exports.decomment(exports.readFile(this.prefsPath));  this.dataStore = JSON.parse(this.str);    this.data = function () {    var fileModifiedDate = File(this.prefsPath).modified;    if (this.currentModifiedDate === fileModifiedDate) {      return this.dataStore;    }else{      this.dataStore = JSON.parse(exports.decomment(exports.readFile(this.prefsPath)));      return this.dataStore;    }  };    this.setting = function (key) {    return this.data()[key];  };    return this;};// Searches within the RFScript locations for a file matching// the name parameter, and executes it.// undoMode is an optional boolean flagexports.doScript = function (name, entireScript) {  if(entireScript){undoMode = UndoModes.entireScript;}else{undoMode = undefined}  var script = exports.filesMatching(name)[0];  var title = script.displayName.replace(/^\d\d\d_|\.jsx?$|\.scptd?$/g, "");  app.doScript(script, undefined, undefined, undoMode, title);};exports.pointIsWithinBounds = function (point, bounds) {  return (point[0] >= bounds[1] && point[0] <= bounds[3]) &&         (point[1] >= bounds[0] && point[1] <= bounds[2]);};exports.decideEnd = function (line, top) {  var end;  var bottom = (top !== true);  if (bottom) {    if (line.paths[0].pathPoints[0].anchor[1] > line.paths[0].pathPoints[-1].anchor[1]) {      end = line.paths[0].pathPoints[0];    }else{      end = line.paths[0].pathPoints[-1];    }  }else{    if (line.paths[0].pathPoints[0].anchor[1] < line.paths[0].pathPoints[-1].anchor[1]) {      end = line.paths[0].pathPoints[0];    }else{      end = line.paths[0].pathPoints[-1];    }  }  return end;};exports.ProgressBar = function (title, subTitle, stop) {  var w = new Window ("palette");  w.title = w.add("statictext",undefined,title);  w.title.alignment = 'center';  w.bar = w.add ("progressbar", undefined, 0, stop);  w.bar.preferredSize = [400,20];  if (subTitle !== '') {    w.subTitle = w.add("statictext",undefined,subTitle);    w.subTitle.alignment = 'right';  }  return w;};// This finds any files whose name matches the match parameter.// It will only check in the folders "Library" & "Menus" inside "InDesign-Extended".// Returns an array of File objects.exports.filesMatching = function (match) {  var rfscripts  = [];  var theFiles   = [];  var theFolders = Folder(Folder.extendables.parent).folders();  for (var i = 0; i < theFolders.length; i++) {    if (!theFolders[i].name.match(/^Library$|Menus/)) {continue;}    rfscripts = rfscripts.concat(theFolders[i].getFilesRecursive());  }  rfscripts = exports.returnFilesMatching(match, rfscripts);  return rfscripts;};exports.returnFilesMatching = function (query, theFiles) {  query.ignoreCase = true;  var matchingFiles = [];  for (var i = 0; i < theFiles.length; i++) {    if (typeof(theFiles[i]) == 'undefined') {continue;}    if (theFiles[i].displayName.match(query)) {      matchingFiles.push(theFiles[i]);    }  }  return matchingFiles;};exports.IDScriptsFolder = function () {  return Folder.extendables.parent.parent;};exports.IDRockfaxFolder = function () {  return Folder.extendables.parent;};exports.IDMenuFolder = function () {  return Folder(Folder.extendables.parent.parent.folders(CustomScriptFolderName)).folders('Menus');};exports.IDPreferencesFolder = function () {  return Folder(Folder.extendables.parent.parent.folders(CustomScriptFolderName)).folders('Library')[0].folders('Preferences')[0];};exports.IDMenuFolders = function () {  return Folder(Folder(Folder.extendables.parent.parent.folders(CustomScriptFolderName)).folders('Menus')).folders();};exports.uniq = function (array) {  var temp = {};  for (var i = 0; i < array.length; i++)      temp[array[i]] = true;  var r = temp.keys();  return r;};// Mac only.exports.tink = function () {  app.doScript('do shell script "afplay /System/Library/Sounds/Tink.aiff"', ScriptLanguage.APPLESCRIPT_LANGUAGE);};// Mac only.exports.basso = function () {  app.doScript('do shell script "afplay /System/Library/Sounds/Basso.aiff"', ScriptLanguage.APPLESCRIPT_LANGUAGE);};// Mac only.exports.say = function (what) {  what = what.toString();  app.doScript('do shell script "say \'' + what + '\'"', ScriptLanguage.APPLESCRIPT_LANGUAGE);};exports.changeCharacterStyleByGrep = function (where, grepQuery, styleName) {  // try {    app.findGrepPreferences    = null;    app.changeGrepPreferences  = null;    app.findGrepPreferences.findWhat = grepQuery;    app.changeGrepPreferences.appliedCharacterStyle = styleName;    return where.changeGrep();  // } catch (e) {  //   // logError(e, arguments.callee.name);  // }};exports.alert = function (msg, title) {  var w = new Window ("dialog", title);    w.alignChildren = "right";    w.orientation = "column";  var myInputGroup = w.add ("group");    myInputGroup.preferredSize = [350,50];    myInputGroup.alignChildren = "bottome";    var myText = myInputGroup.add ("statictext");    myText.text = msg;  var myButtonGroup = w.add ("group");  myButtonGroup.add ("button", undefined, "Cancel");  myButtonGroup.add ("button", undefined, "OK");      if(w.show() == 1){return true;}else{return false;}};exports.changeParagraphStyleStyle = function (where, originalStyleNames, newStyleName) {  try {    app.findGrepPreferences    = null;    app.changeGrepPreferences  = null;    app.changeGrepPreferences.appliedParagraphStyle = newStyleName;    for (var i = 0; i < originalStyleNames.length; i++) {      app.findGrepPreferences.appliedParagraphStyle = originalStyleNames[i];      where.parentStory.changeGrep();    }  } catch (e) {    // logError(e, arguments.callee.name);  }};exports.changeParagraphStyleByGrep = function (where, grepQuery, styleName) {  // try {    app.findGrepPreferences    = null;    app.changeGrepPreferences  = null;    app.findGrepPreferences.findWhat = grepQuery;    app.changeGrepPreferences.appliedParagraphStyle = styleName;    return where.parentStory.changeGrep();  // } catch (e) {  //   // logError(e, arguments.callee.name);  // }};exports.changeCharacterStyleByMatchingStyle = function (where, oldStyle, newStyle) {  try {    app.findGrepPreferences    = null;    app.changeGrepPreferences  = null;    app.findGrepPreferences.appliedCharacterStyle = oldStyle;    app.changeGrepPreferences.appliedCharacterStyle = newStyle;    return where.changeGrep();  } catch (e) {    // logError(e, arguments.callee.name);  }};// exports.copyTextToClipboard = function (text)// {//   var fakeFrame = app.textFrames.add();//   fakeFrame.contents = text;//   app.select(fakeFrame.contents);// };// exports.pbPaste = exports.copyTextToClipboard;exports.findMatchingValues = function (list, hash) {  if (typeof(hash) == 'undefined') {hash = RFMagicScriptLookup;}  var keys   = hash.keys();  var string = list.join("___");  for (var i = 0; i < keys.length; i++) {    var items     = keys[i].split("&&");    var len       = items.length;    var search    = RegExp(items.join("|"), "g");    var match     = string.match(search);    if (!match) {continue;}    match = match.uniq();    var matchLen  = match.length;    if (matchLen === len) {      return hash[keys[i]];    }  }  return false;};exports.objectStyleSet = function (items) {  return items.map(function (e) {if (e.appliedObjectStyle) {return e.appliedObjectStyle.name;}}).uniq();};exports.labelSet = function (items) {  var items = items.map(function (e) {return e.label}).uniq();  // var index = items.indexOf('');  // items.splice(index, 1);  return items;};exports.objectStyleAndLabelSet = function (items) {  return [exports.objectStyleSet(items), exports.labelSet(items)].flatten();};// Pass in an object and optionally a boolean to indicate if the item is a// member of a group. In practice this happens withing the function recursively// with the subitems if the original item is a group.exports.decideScript = function (sel) {  var classNames = sel.map(function (e) {return e.constructor.name;}).uniq();  var labels;  var styles;    // if (classNames[0] == 'Character') {  //   var font = sel[0].appliedFont.name;  //   if (font == "RFNumbers\tRegular") {  //     return ['Bump Route Numbers'];  //   }  // } else   if (['Character', 'InsertionPoint', 'Word', 'Text', 'Paragraph', 'Line', 'Sentence'].contains(classNames[0])) {    // Do nothing for the moment with these types.    // return false;    styles = [sel[0].appliedFont.name];  } else {    styles = exports.objectStyleSet(sel);  }    try{    labels = exports.labelSet(sel);  }catch(e){}    // This bit is here for when the selection is text-based.  var stylesAndLabels;  if (typeof(labels) == 'undefined') {    stylesAndLabels = styles;  } else {    stylesAndLabels = styles.concat(labels);  }      if (classNames.length === 1 && classNames[0] == 'Group' && labels[0] ==='') {    var pageItems = sel[0].pageItems.everyItem().getElements();    var tmp = exports.decideScript(pageItems);    if (tmp !== false) {return tmp;}  }  return exports.findMatchingValues(stylesAndLabels, RFMagicScriptLookup);};/** * @desc Save the current find/change options and preferences, * ready to be restored later. * @param {String|level} an optional parameter to control what is saved, * the string is checked for matches: *    level.match(/1/) will save the text options/preferences. *    level.match(/2/) will save the grep options/preferences. *    level.match(/3/) will save the glyph options/preferences. *    level.match(/4/) will save the object options/preferences. * * @example *     saveFindChangeProps("24"); // saves just the grep and object stuff. */exports.saveFindChangeProps = function (level){  exports._savedFindChangeProps = exports.getFindChangeProps(level);};exports.restoreFindChangeProps = function (){  exports._restoreFindChangeProps(exports._savedFindChangeProps);};exports.getFindChangeProps = function (level){  if(typeof(level) == 'undefined') {level = "1234"}  var props = {};  if (level.match(/1/)) {    props["findChangeTextOptions"]  = app.findChangeTextOptions.properties;    props["findTextPreferences"]    = app.findTextPreferences.properties;    props["changeTextPreferences"]  = app.changeTextPreferences.properties;  }  if (level.match(/2/)) {    props["findChangeGrepOptions"]  = app.findChangeGrepOptions.properties;    props["findGrepPreferences"]    = app.findGrepPreferences.properties;    props["changeGrepPreferences"]  = app.changeGrepPreferences.properties;  }  if (level.match(/3/)) {    props["findChangeGlyphOptions"]   = app.findChangeGlyphOptions.properties;    props["findGlyphPreferences"]     = app.findGlyphPreferences.properties;    props["changeGlyphPreferences"]   = app.changeGlyphPreferences.properties;  }  if (level.match(/4/)) {    props["findChangeObjectOptions"]  = app.findChangeObjectOptions.properties;    props["findObjectPreferences"]    = app.findObjectPreferences.properties;    props["changeObjectPreferences"]  = app.changeObjectPreferences.properties;  }  return props;};exports._restoreFindChangeProps = function (options){  var keys = [];  for (var key in options) {    if (options.hasOwnProperty(key) && !(options[key] instanceof Function)) keys.push(key);  }  for (var i = 0; i < keys.length; i++) {    app[keys[i]].properties = options[keys[i]]  }};exports.decomment = function (string) {  return string.replace(/^[ \t]*\/\/[^\r\n]*\n*/gm, "");};exports.readFile = function (thePath) {  if (File(thePath).exists === true) {    var file = File(thePath);    file.open("r");    file.encoding = 'UTF-8';    var theText = file.read();    file.close();    return theText;  }else{    alert("File does not exist:\n" + thePath.join("\n"));  }};exports.findItemById = function (_id, items) {  if (typeof(items) == 'undefined') {items = app.activeWindow.activeSpread.pageItems;}  var res = [];  for (var i = 0; i < items.length; i++) {    if (items[i].id == _id) {       return items[i];     }   }};exports.findItemsByStyle = function (searchStyle, items) {  if (typeof(items) == 'undefined') {items = app.activeWindow.activeSpread.pageItems;}  var res = [];  if (searchStyle.constructor.name == 'Array') {searchStyle = RegExp(searchStyle.join("|"));}  for (var i = 0; i < items.length; i++) {    if (items[i].appliedObjectStyle && items[i].appliedObjectStyle.name.match(searchStyle)) {       res.push(items[i]);     }   }  return res;};exports.findItemsByLabel = function (label, items) {  if (typeof(items) == 'undefined') {items = app.activeWindow.activeSpread.pageItems;}  if (label.constructor.name == 'Array') {label = RegExp(label.join("|"));}  var result = [];  for (var i = 0; i < items.length; i++) {    try{      if (items[i].label.match(label)){         result.push(items[i]);       }     }catch(e){}   }  return result;};exports.findItemsByClass = function (klass, items) {  if (typeof(items) == 'undefined') {items = app.activeWindow.activeSpread.pageItems;}  if (klass.constructor.name == 'Array') {klass = RegExp(klass.join("|"));}  if (klass.constructor.name == 'String') {klass = RegExp(klass);}  var result = [];  for (var i = 0; i < items.length; i++) {    if (items[i].getElements()[0].constructor.name.match(klass)){       result.push(items[i]);    }else{      if (items[i].constructor.name.match('Group')) {        result = result.concat(exports.findItemsByClass(klass, items[i].pageItems));      }    }   }  return result;};exports.findItemByLabel = function (label, items) {  if (typeof(items) == 'undefined') {items = app.activeWindow.activeSpread.pageItems;}  return findItemsByLabel(label, items)[0];};exports.reallyFitTextFramesToContent = function (textFrames) {  if (typeof(textFrames) !== Array) {    textFrames = [textFrames];  }    textFrames = textFrames.flatten();  for (var i=0; i<textFrames.length; i++) {    var tf = textFrames[i];        // try {    //   app.select(tf);    // }catch(e){    //   continue;    // }        // app.select(tf);    var originalCenter = tf.center();    tf.fit( FitOptions.FRAME_TO_CONTENT );    var gb = tf.geometricBounds;    if (!tf.contents.match(/\w+/)) {continue;}        if (tf.parentStory.justification === Justification.CENTER_ALIGN) {      var left = true;      while (!tf.overflows) {        if (left) {          gb[3]--;        }else{          gb[1]++;        }        tf.geometricBounds = gb;        left = !left;      }      gb = tf.geometricBounds;            if (left) {        gb[3]++;      }else{        gb[1]--;      }      tf.geometricBounds = gb;    }else if(tf.parentStory.justification === Justification.RIGHT_ALIGN) {      while (!tf.overflows) {        gb[1]++;        tf.geometricBounds = gb;      }      gb = tf.geometricBounds;      gb[1]--;      tf.geometricBounds = gb;    }else if(tf.parentStory.justification === Justification.LEFT_ALIGN) {      while (!tf.overflows) {        gb[3]--;        tf.geometricBounds = gb;      }      gb = tf.geometricBounds;      gb[3]++;      tf.geometricBounds = gb;    }    tf.geometricBounds = gb;        // var lines = tf.lines.everyItem().getElements().map(function (x) {return x.contents});        while (!tf.overflows) {      gb[2]--;      tf.geometricBounds = gb;    }    gb = tf.geometricBounds;    gb[2]++;        tf.geometricBounds = gb;        tf.setCenter(originalCenter);  }};exports.quickApply = function(namePattern) {    // var preferences = require("preferences");  var prefs = preferences.Store(/quick_apply_prefs/);    app.menuActions.item("Quick Apply...").invoke();    var commands = [    "Include Paragraph Styles (p:)",    "Include Character Styles (c:)",    "Include Object Styles (o:)",    "Include Menu Commands (m:)",    "Include Scripts (s:)",    "Include Table Styles (t:)",    "Include Text Variables (v:)",    "Include Cell Styles (e:)",    "Include Conditions (ct:)"  ];    var pattern = RegExp(namePattern);  for (var i = 0; i < commands.length; i++) {    if (commands[i].match(pattern)) {      try {        var action = app.menuActions.item(commands[i]);        if (!action.checked) {          action.invoke();        }      }catch(e){}    }else{      try {        var action = app.menuActions.item(commands[i]);        if (action.checked) {          action.invoke();        }      }catch(e){}    }  }};exports.paste = function () {  File("/Applications/Adobe InDesign CS6/Scripts/RF-InDesign-Extended/Library/Misc/temp_applescript.scpt").execute();};exports.rgbaFillColorValuesForObject = function (obj) {  return exports.rgbaColorValuesForObject(obj, "fillColor");};exports.rgbaTextFillColorValuesForObject = function (obj) {  return exports.rgbaColorValuesForObject(obj, "texts.0.fillColor");};exports.rgbaTextStrokeColorValuesForObject = function (obj) {  return exports.rgbaColorValuesForObject(obj, "texts.0.strokeColor");};exports.rgbaStrokeColorValuesForObject = function (obj) {  return exports.rgbaColorValuesForObject(obj, "strokeColor");};exports.rgbaGapColorValuesForObject = function (obj) {  return exports.rgbaColorValuesForObject(obj, "gapColor");};exports.rgbaColorValuesForObject = function (obj, propertyToCheck) {  var color_values;  var r,g,b,rt,gt,bt;     var color = exports.getProperty(obj, propertyToCheck);      // If it's a gradient, I'm currently not really interested in it, so just  // return anything. I've used 0.69 so it's conspicuous.  if (color.constructor.name === "Gradient") {    return [0.69,0.69,0.69,0.69];  }    var tint = exports.getProperty(obj, propertyToCheck.replace(/Color/g, "Tint"));  tint = tint >=0 ? 1.0 - (tint / 100.0) : 0.0;  // random magic number...  tint /= .92592592593;  var color_name = color.name;    if (color_name.match(/^black$|^paper$|^none$/i)) {    if (color_name.match(/^black$/i)) {            color_values = [0,0,0];    }else if (color_name.match(/^paper$/i)) {      color_values = [255,255,255];    }else{      return null;    }  }else{    try{    color.space = ColorSpace.RGB;    color_values = color.colorValue;    }catch(e){      return [];      app.select(obj)      alert(obj);      bork    }    try{      app.undo();    }catch(e){}  }  r = color_values[0];g = color_values[1];b = color_values[2];  rt = r + (tint * (255 - r)); gt = g + (tint * (255 - g)); bt = b + (tint * (255 - b));    var opacity = obj.transparencySettings.blendingSettings.opacity;    // return [rt,gt,bt,opacity].map(function (x) {return Math.round(x)});  return [rt,gt,bt].map(function (x) {return x/255.0}).concat(opacity/100.0);};exports.getProperty = function (obj, prop) {    var parts = prop.split('.'),    last = parts.pop(),    l = parts.length,    i = 1,    current = parts[0];    if (typeof(current) === 'undefined') {    return obj[prop];  }    while((obj = obj[current]) && i < l) {    current = parts[i];    i++;  }  if(obj) {    return obj[last];  }};